# Code Review Findings: Feature Provisioning Use Cases

**Branch:** `feature-provisioning-use-cases`
**Target:** `main`
**Date:** 2025-12-31

The following issues were identified during the code review of the provisioning and authentication logic.

### **1. Write-Only Telemetry Salt Fallback (Logic Bug)**
**Severity:** **High**
**File:** `core/data/src/main/kotlin/com/locus/core/data/repository/ConfigurationRepositoryImpl.kt`

**Problem:**
The implementation successfully writes the Telemetry Salt to standard `SharedPreferences` as a fallback (adhering to the memory requirement: "fall back to standard Context.MODE_PRIVATE for the Telemetry Salt").
```kotlin
// Writes to Standard Prefs
prefs.edit().putString(SecureStorageDataSource.KEY_SALT, salt).apply()
```
However, the retrieval method `getTelemetrySalt()` delegates **exclusively** to `secureStorage`:
```kotlin
override suspend fun getTelemetrySalt(): String? {
    // Only reads from Secure Storage
    return secureStorage.getTelemetrySalt()
}
```
If `SecureStorageDataSource` (which manages `RuntimeCredentials` in `EncryptedSharedPreferences`) fails or is cleared, the fallback value stored in standard `prefs` is **never read**. The fallback mechanism is effectively "Write-Only," rendering it useless for recovery or degraded states.

**Proposed Fix:**
Update `getTelemetrySalt()` to implement the fallback read logic:
1.  Attempt to read from `secureStorage`.
2.  If null, attempt to read from standard `prefs`.

```kotlin
override suspend fun getTelemetrySalt(): String? {
    return secureStorage.getTelemetrySalt()
        ?: prefs.getString(SecureStorageDataSource.KEY_SALT, null)
}
```

---

### **2. Misleading Error Mapping for Local Resources**
**Severity:** **Medium**
**File:** `core/domain/src/main/kotlin/com/locus/core/domain/usecase/ProvisioningUseCase.kt` & `core/data/src/main/kotlin/com/locus/core/data/infrastructure/ResourceProviderImpl.kt`

**Problem:**
In `ResourceProviderImpl`, a failure to load the local asset `locus-stack.yaml` throws a raw `RuntimeException`:
```kotlin
throw RuntimeException("Failed to load locus-stack.yaml", e)
```
In `ProvisioningUseCase`, this exception is caught and mapped to a **NetworkError**:
```kotlin
} catch (e: Exception) {
    return LocusResult.Failure(DomainException.NetworkError.Generic(e))
}
```
Labeling a missing local asset as a `NetworkError` is misleading for debugging and UI feedback. It suggests connectivity issues when the problem is actually an app integrity/installation issue.

**Proposed Fix:**
1.  In `ResourceProviderImpl`, catch the IO exception and return `null` or a specific domain result, OR let the UseCase handle specific exceptions.
2.  In `ProvisioningUseCase`, map this specific failure to `DomainException.ProvisioningError.InvalidConfiguration` or a new `InternalError` type, not `NetworkError`.

---

### **3. Hardcoded Infrastructure Keys (Magic Strings)**
**Severity:** **Low (Maintenance)**
**File:** `ProvisioningUseCase.kt`, `RecoverAccountUseCase.kt`

**Problem:**
Critical CloudFormation Output keys (`RuntimeAccessKeyId`, `RuntimeSecretAccessKey`, `BucketName`) and Tag keys (`aws:cloudformation:stack-name`) are hardcoded as string literals inside the Use Cases. These keys implicitly couple the Android Domain layer to the `locus-stack.yaml` template definition. If the YAML template changes, the Android app will silently fail to parse outputs.

**Proposed Fix:**
Move these keys to a shared `InfrastructureContract` object (or the existing `InfrastructureConstants.kt` mentioned in memory) within the Domain layer to serve as a single source of truth.

---

### **4. Unsafe/Brittle Casting in AuthRepository**
**Severity:** **Low (Style/Safety)**
**File:** `core/data/src/main/kotlin/com/locus/core/data/repository/AuthRepositoryImpl.kt`

**Problem:**
```kotlin
return result as LocusResult.Failure
```
While likely safe given the current sealed class hierarchy, explicit casting is brittle. If `LocusResult` is expanded to include other states (e.g., `Loading`), this code will throw a `ClassCastException` at runtime.

**Proposed Fix:**
Use a `when` expression or standard unwrapping to handle the failure case safely without explicit casting.
