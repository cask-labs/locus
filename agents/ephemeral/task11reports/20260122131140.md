# Task 11 Analysis: Admin Upgrade & Recovery Gaps

## 1. Ambiguous `StackName` Logic in Upgrade Flow

**Finding:** The plan introduces `RuntimeCredentials.stackName` and instructs the `UpgradeAccountUseCase` to use it as a CloudFormation Parameter. This creates a high risk of "Nested Naming" bugs.

**Deep Analysis:**
The plan requires adding `stackName` to `RuntimeCredentials` (Step 4) and using it in `UpgradeAccountUseCase` (Step 9):
> "Call stackProvisioningService.updateAndPollStack with parameters: StackName: creds.stackName"

There is a critical semantic ambiguity between:
1.  **AWS Stack Name:** The identifier of the stack resource (e.g., `locus-user-Pixel7`). This is needed to *target* the stack for updates.
2.  **Template Parameter `StackName`:** The user-provided device name (e.g., `Pixel7`) used inside the template to generate resource names (e.g., `UserName: !Sub "locus-user-${StackName}"`).

If `RuntimeCredentials.stackName` stores the AWS Stack Name (`locus-user-Pixel7`) to support targeting, but is passed as the *Template Parameter* `StackName`, the resulting User Name will be `locus-user-locus-user-Pixel7`, changing the identity and breaking continuity.

**Resolution:**
1.  **Strict Definition:** Define `RuntimeCredentials.stackName` strictly as the **AWS Stack Name** (to enable targeting).
2.  **Parameter Handling:** In `UpgradeAccountUseCase`, do **not** pass `StackName` in the `parameters` map. Instead, rely on CloudFormation's `UsePreviousValue` behavior for the existing `StackName` (Device Name) parameter.
3.  **Code Change:** Ensure `StackProvisioningService.updateAndPollStack` supports `UsePreviousValue` or merging parameters.

## 2. Non-Existent `BucketName` Parameter

**Finding:** The plan instructs to "REMOVE: BucketName" from `locus-stack.yaml`, but the current template contains no such parameter.

**Deep Analysis:**
The current `locus-stack.yaml` generates the bucket name dynamically (`Ref: LocusDataBucket`). The parameter `BucketName` does not exist. However, the existing code in `RecoverAccountUseCase.kt` *incorrectly* passes a `BucketName` parameter, which would currently cause deployment failures.

**Resolution:**
1.  **Template:** No action required for removal (parameter doesn't exist).
2.  **Code:** The refactoring of `RecoverAccountUseCase` (Step 8) is critical not just for "Takeover" logic, but to fix the broken parameter passing. The implementation must explicitly **stop** passing `BucketName` to the `UpdateStack` call.

## 3. Explicit Tagging for Robust Discovery

**Finding:** The "Takeover" strategy relies on discovering the Stack Name from S3 buckets, presumably via the system tag `aws:cloudformation:stack-name`. Relying on implicit system tags is brittle and may be subject to stricter IAM visibility permissions in some contexts.

**Deep Analysis:**
To "Takeover" a stack, we must know its exact AWS Stack Name. While `aws:cloudformation:stack-name` is usually present, the `LocusDataBucket` definition in the template currently only includes `LocusRole: DeviceBucket`. Explicitly exposing the stack name via a custom tag ensures the `RecoverAccountUseCase` can robustly identify the parent stack of a bucket.

**Resolution:**
**Modify CloudFormation Template (Step 3):**
Add a specific tag to the `LocusDataBucket` resource:
```yaml
Tags:
  - Key: LocusStackName
    Value: !Ref "AWS::StackName"
```
Update `RecoverAccountUseCase` to prefer this tag for discovery.

## 4. Spec Conflict: "New Identity" vs. "Same Stack"

**Finding:** Behavioral Spec R1.1300 mandates creating a "new unique user identity... distinct from any previous users". The "Takeover" strategy reuses the Stack, which might be interpreted as violating "New Identity" if not clarified.

**Deep Analysis:**
The "Takeover" strategy rotates the `KeySerial`, which forces the destruction of the old IAM User and creation of a new one (within the same Stack). This technically satisfies "New Identity". However, the spec language "Link Existing Store" combined with "distinct from previous" strongly suggests a "Side-by-Side" resource model (Linker) rather than a "In-Place Update" model (Takeover).

**Resolution:**
**Update Behavioral Spec (Step 1):**
Explicitly amend R1.1300 and R1.1100 to describe the "Takeover" mechanism:
> "When recovering, the system shall **take ownership** of the existing infrastructure by rotating the identity keys, thereby invalidating previous credentials while retaining the storage history."

## 5. Security Validation in Upgrade Flow

**Finding:** The plan mentions "Validate keys" in the UI ViewModel but does not explicitly enforce a "Dry Run" check (R1.100) before triggering the Upgrade Worker.

**Deep Analysis:**
The `ProvisioningWorker` runs in the background. If invalid keys are passed, it will fail and might leave the app in a "Working" state or require complex error handling. Validating credentials synchronously (or immediately asynchronously) before dispatching the Worker is a better UX pattern, consistent with Onboarding.

**Resolution:**
Ensure the `AdminUpgradeViewModel` reuses the `AuthRepository` (or equivalent) logic to perform a `sts:GetCallerIdentity` (Dry Run) check *before* storing credentials and dispatching the worker.
