# Technical Deep Dive: Credential Storage Contract

## Overview
Secure storage of AWS credentials is paramount. Locus uses `EncryptedSharedPreferences` to store keys. This document defines the exact key schema and the security boundary between "Bootstrap" (User-Entered) and "Runtime" (System-Generated) credentials.

## Storage Schema

**File Name:** `locus_secure_prefs`

### 1. Bootstrap Credentials (Temporary)
These are the keys the user enters manually (or via paste) during Onboarding or Admin Upgrade.

| Key | Type | Requirement | Description |
|-----|------|-------------|-------------|
| `auth.bootstrap.ak` | String | Mandatory | Access Key ID |
| `auth.bootstrap.sk` | String | Mandatory | Secret Access Key |
| `auth.bootstrap.st` | String | Mandatory | Session Token (AWS STS) |

**Lifecycle:**
*   **Written:** When user submits the Credential Entry form.
*   **Read:** By `CloudFormationClient` during provisioning.
*   **Deleted:** IMMEDIATELY after successful promotion to Runtime.

### 2. Runtime Credentials (Permanent)
These are the keys generated by CloudFormation and returned in the Stack Outputs.

| Key | Type | Requirement | Description |
|-----|------|-------------|-------------|
| `auth.runtime.ak` | String | Mandatory | Access Key ID |
| `auth.runtime.sk` | String | Mandatory | Secret Access Key |
| `auth.runtime.bucket` | String | Mandatory | The S3 Bucket Name |
| `auth.runtime.region` | String | Optional | Region (defaults to `us-east-1` if missing, but should be saved) |
| `auth.runtime.role` | String | Optional | "USER" or "ADMIN" (For local permission checks) |

**Lifecycle:**
*   **Written:** During `FinalizingSetup` state.
*   **Read:** By `S3Client` (via Dynamic Credentials Provider) for every request.
*   **Deleted:** ONLY during "Factory Reset" (Danger Zone).

## Atomic Promotion Transaction

To prevent a "Zombie State" (where Runtime keys are saved but Bootstrap keys linger, or vice versa), the promotion must be atomic.

> **Note:** The `.commit()` method is blocking. This function must be called on a background thread (e.g., `Dispatchers.IO`) to avoid blocking the Main thread.

```kotlin
@WorkerThread
fun promoteToRuntime(runtimeCreds: RuntimeCredentials) {
    sharedPreferences.edit()
        // 1. Write New Keys
        .putString("auth.runtime.ak", runtimeCreds.accessKeyId)
        .putString("auth.runtime.sk", runtimeCreds.secretAccessKey)
        .putString("auth.runtime.bucket", runtimeCreds.bucketName)
        // 2. Erase Old Keys
        .remove("auth.bootstrap.ak")
        .remove("auth.bootstrap.sk")
        .remove("auth.bootstrap.st")
        // 3. Commit Atomically
        .commit()
}
```

## Admin Upgrade Replacement

When upgrading to Admin, the system **replaces** the existing Runtime keys with the new Admin keys.

```kotlin
@WorkerThread
fun replaceWithAdmin(adminCreds: RuntimeCredentials) {
    sharedPreferences.edit()
        // Overwrite existing runtime keys
        .putString("auth.runtime.ak", adminCreds.accessKeyId)
        .putString("auth.runtime.sk", adminCreds.secretAccessKey)
        .putString("auth.runtime.role", "ADMIN")
        // Remove bootstrap keys (used for the upgrade)
        .remove("auth.bootstrap.ak")
        .remove("auth.bootstrap.sk")
        .remove("auth.bootstrap.st")
        .commit()
}
```

## Security Constraints
1.  **Never Log:** These keys must strictly NEVER appear in Logcat or S3 Logs.
2.  **Memory:** `BootstrapCredentials` objects in memory should be nullable and set to null as soon as possible.
3.  **Root Access:** On rooted devices, `EncryptedSharedPreferences` keys can theoretically be extracted. This is an accepted risk for a "User-Owned" device model (similar to Signal/WhatsApp local storage).
